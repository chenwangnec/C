/*
2016-04-10 11:06
浮点数的存错所带来的问题
float和double都不能保证可以精确的存储一个小数

float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。
其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~+1.79E+308。

例如：
+1.1111111111111111111111*2^127（小数点后面23个1，由于尾数的范围1～2，其最高位总为1，故只需存取小数部分，所以小数为是23位1），约等于2*2^127=3.4*10^38。为3.4*10^38负数亦然。
Double的计算与此类似，double的符号位为63位，指数为62～52位，共11位。表示的范围为-1024～1023。尾数为51～0。表示的范围为+1.1111111111111111..11111*2^1023（小数点后面52个1）为1.7*10^308。负数亦然。
*/
#include <stdio.h>
int main()
{
	float i;
	float sum = 0;
	for (i = 1; i <= 100;++i)
	{
		sum = sum + 1 / i;
	}
	printf("sum=%f\n",sum);
	getchar();
	return 0;
}
/*
C语言中，float在内存中的储存方式
浮点型变量在计算机内存中占用4字节（Byte）,即32-bit。

遵循IEEE-754格式标准。 一个浮点数由2部分组成：底数m 和 指数e。

±mantissa × 2exponent （注意，公式中的mantissa 和 exponent使用二进制表示）

底数部分 使用２进制数来表示此浮点数的实际值。

指数部分 占用８-bit的二进制数，可表示数值范围为0－255。

但是指数应可 正可负，所以IEEE规定，此处算出的次方须减去127才是真正的指数。所以float的指数可从 -126到128. 底数部分实际是占用24-bit的一个值，由于其最高位始终为 1 ，所以最高位省去不存储，在存储中只有23-bit。

到目前为止， 底数部分 23位 加上指数部分 8位 使用了31位。那么前面说过，float是占用4个字节即32-bit,那么还有一位是干嘛用的呢？ 还有一位，其实就是4字节中的最高位，用来指示浮点数的正负，当最高位是1时，为负数，最高位是0时，为正数。

浮点数据就是按下表的格式存储在4个字节中：

Address+0 Address+1 Address+2 Address+3 Contents

SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM
S: 表示浮点数正负，1为负数，0为正数

E: 指数加上127后的值的二进制数

M: 24-bit的底数（只存储23-bit）

主意：这里有个特例，浮点数 为0时，指数和底数都为0，但此前的公式不成立。因为2的0次方为1，所以，0是个特例。当然，这个特例也不用认为去干扰，编译器会自动去识别。 通过上面的格式，我们下面举例看下-12.5在计算机中存储的具体数据：

Address+0 Address+1 Address+2 Address+3 Contents

0xC1 0x48 0x00 0x00
接下来我们验证下上面的数据表示的到底是不是-12.5，从而也看下它的转换过程。 由于浮点数不是以直接格式存储，他有几部分组成，所以要转换浮点数，首先要把各部分的值分离出来。




Address+0 Address+1 Address+2 Address+3

格式SEEEEEEE EMMMMMMM MMMMMMMM MMMMMMMM

二进制 11000001 01001000 00000000 00000000

16进制 C1 48 00 00

可见：

S: 为1，是个负数。

E:为 10000010 转为10进制为130，130-127=3，即实际指数部分为3.

M:为 10010000000000000000000。

这里，在底数左边省略存储了一个1，

使用 实际底数表示为1.10010000000000000000000 到此，我们吧三个部分的值都拎出来了，现在，我们通过指数部分E的值来调整底数部分M的值。调整方法为：如果指数E为负数，底数的小数点向左移，如果指数E为正数，底数的小数点向右移。小数点移动的位数由指数E的绝对值决定。 这里，E为正3，使用向右移3为即得： 1100.10000000000000000000 至次，这个结果就是12.5的二进制浮点数，将他换算成10进制数就看到12.5了，如何转换，看下面： 小数点左边的1100 表示为 (1 × 23) + (1 × 22) + (0 × 21) + (0 × 20), 其结果为 12 。 小数点右边的 .100… 表示为 (1 × 2-1) + (0 × 2-2) + (0 × 2-3) + ... ，其结果为.5 。 以上二值的和为12.5， 由于S 为1，使用为负数，即-12.5 。所以，16进制 0XC1480000 是浮点数 -12.5 。

上面是如何将计算机存储中的二进制数如何转换成实际浮点数，下面看下如何将一浮点数装换成计算机存储格式中的二进制数。 举例将17.625换算成 float型。

首先，将17.625换算成二进制位：

10001.101 ( 0.625 = 0.5+0.125, 0.5 即 1/2, 0.125即 1/8 如果不会将小数部分转换成二进制，请参考其他书籍。)

再将 10001.101 向右移，直到小数点前只剩一位 成了 1.0001101 x 2的4次方（因为右移了4位）。此时 我们的底数M和指数E就出来了： 底数部分M，因为小数点前必为1，所以IEEE规定只记录小数点后的就好，所以此处底数为 0001101 。 指数部分E，实际为4，但须加上127，固为131，即二进制数 10000011 符号部分S，由于是正数，所以S为0. 综上所述，17.625的 float 存储格式就是： 0 10000011 00011010000000000000000 转换成16进制：0x41 8D 00 00 所以，一看，还是占用了4个字节。

下面，我做了个有趣的实验，就是由用户输入一个浮点数，程序将这个浮点数在计算机中存储的二进制直接输出，来看看我们上面所将的那些是否正确。 有兴趣同学可以copy到VC6.0中去试试~！

#include<iostream.h>

#define uchar unsigned char

void binary_print(uchar c)

{

for(int i = 0; i < 8; ++i)

{

if((c << i) & 0x80)

cout << '1'; else cout << '0';

}

cout << ' ';

}

void main()
{

float a;

uchar c_save[4];

uchar i;

void *f;

f = &a;

cout<<"请输入一个浮点数:";

cin>>a;

cout<<endl;

for(i=0;i<4;i++)

{

c_save[i] = *((uchar*)f+i);

}

cout<<"此浮点数在计算机内存中储存格式如下："<<endl;

for(i=4;i!=0;i--)

binary_print(c_save[i-1]);

cout<<endl;

}
*/