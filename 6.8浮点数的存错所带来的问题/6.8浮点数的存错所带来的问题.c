/*
2016-04-10 11:06
浮点数的存错所带来的问题
float和double都不能保证可以精确的存储一个小数

float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。
其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~+1.79E+308。

例如：
+1.1111111111111111111111*2^127（小数点后面23个1，由于尾数的范围1～2，其最高位总为1，故只需存取小数部分，所以小数为是23位1），约等于2*2^127=3.4*10^38。为3.4*10^38负数亦然。
Double的计算与此类似，double的符号位为63位，指数为62～52位，共11位。表示的范围为-1024～1023。尾数为51～0。表示的范围为+1.1111111111111111..11111*2^1023（小数点后面52个1）为1.7*10^308。负数亦然。
*/
#include <stdio.h>
int main()
{
	float i;
	float sum = 0;
	for (i = 1; i <= 100;++i)
	{
		sum = sum + 1 / i;
	}
	printf("sum=%f\n",sum);
	getchar();
	return 0;
}